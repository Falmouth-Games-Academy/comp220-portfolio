#version 330 core

layout(location = 0) in vec3 vertexPos;
layout(location = 1) in vec3 vertexColour;
layout(location = 2) in vec3 vertexNormal;
layout(location = 3) in vec2 vertexUv;
layout(location = 4) in int boneIndices[4];
layout(location = 5) in float boneWeights[4];

out vec3 fragColour;
out vec2 fragUv;
out vec3 fragNormal;

uniform mat4 matWorld; // the global transformation matrix
uniform mat4 matViewProj;  // the global view matrix

uniform mat4 boneTransforms[64]; // bone matrices

uniform float time; // global time

uniform vec3 ambientLightColour;
uniform vec3 directionalLightDirection;
uniform vec3 directionalLightColour;

void main()
{
	// Calculate the position of the vertex based on bones
	vec4 animatedPosition = vec4(0.0f, 0.0f, 0.0f, 0.0f);
	float numAnimatedPositions = 0.0f;

	for (int i = 0; i < 4; i++) {
		if (boneIndices[i] < 0 || boneIndices[i] >= 64) {
			break;
		}

		animatedPosition += (boneTransforms[i] * vec4(vertexPos, 1.0f)) * boneWeights[i];
		numAnimatedPositions += 1.0f;
	}

	// Pass the projected position to the fragment shader
	if (numAnimatedPositions > 0.0f) {
		gl_Position = matViewProj * matWorld * animatedPosition;
	} else {
		gl_Position = matViewProj * matWorld * vec4(vertexPos, 1);
	}

	// Use directional light + ambient light
	float lightFactor = clamp(1.0f - dot(matWorld * vec4(vertexNormal, 0.0f), vec4(directionalLightDirection, 0.0f)), 0.0f, 1.0f);
	fragColour = vertexColour * ambientLightColour + (directionalLightColour * lightFactor);

	// Standard UVs
	fragUv = vertexUv;

	// Send normal to frag shader
	fragNormal = vec3(matWorld * vec4(vertexNormal, 0.0f));
}