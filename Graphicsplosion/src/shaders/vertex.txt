#version 330 core

layout(location = 0) in vec3 vertexPos;
layout(location = 1) in vec3 vertexColour;
layout(location = 2) in vec3 vertexNormal;
layout(location = 3) in vec2 vertexUv;
layout(location = 4) in uint boneIndices[4];
layout(location = 5) in float boneWeights[4];

out vec3 fragColour;
out vec2 fragUv;
out vec3 fragNormal;

uniform mat4 matWorld; // the global transformation matrix
uniform mat4 matViewProj;  // the global view matrix

uniform mat4 boneTransforms[32]; // bone matrices

uniform float time; // global time

uniform vec3 ambientLightColour;
uniform vec3 directionalLightDirection;
uniform vec3 directionalLightColour;

void main()
{
	// Calculate the position of the vertex based on bones
	// If there is at least one bone attached, weight this to the bone
	int numBones = 0;
	if (boneIndices[0] < 32u) {
		vec3 animatedPosition = vec3(0.0f, 0.0f, 0.0f);

		for (int i = 0; i < 4; i++) {
			if (boneIndices[i] < 32u) {
				animatedPosition += (boneTransforms[boneIndices[i]] * vec4(vertexPos, 1.0f)).xyz * boneWeights[i];
			}
		}

		gl_Position = matViewProj * matWorld * vec4(animatedPosition, 1);
	} else {
		numBones = -1;

		// Otherwise use the regular position
		gl_Position = matViewProj * matWorld * vec4(vertexPos, 1);
	}

	// Use directional light + ambient light
	float lightFactor = clamp(1.0f - dot(matWorld * vec4(vertexNormal, 0.0f), vec4(directionalLightDirection, 0.0f)), 0.0f, 1.0f);
	fragColour = vertexColour * ambientLightColour + (directionalLightColour * lightFactor);

	// Standard UVs
	fragUv = vertexUv;

	// Send normal to frag shader
	fragNormal = vec3(matWorld * vec4(vertexNormal, 0.0f));
}